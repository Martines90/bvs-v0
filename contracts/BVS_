// SPDX-License-Identifier: MIT 

pragma solidity ^0.8.7;

import "./SimpleStorage.sol";

contract AccessControl {

    bool public test;
    // events
    event eGrantRole(bytes32 indexed role, address indexed account);
    event eRevokeRole(bytes32 indexed role, address indexed account);

    event eGrantMyPulbicistRole(address indexed political_actor_account, address indexed publicist_account);
    event eRevokeMyPulbicistRole(address indexed political_actor_account, address indexed publicist_account);

    // role => account => bool
    mapping(bytes32 => mapping(address => bool)) public roles;

    // political_actor_account => publicist_account => bool
    mapping(address => mapping(address => bool)) public myPublicists;

    // admin roles
    bytes32 private constant INSTITUTION_ADMIN = keccak256(abi.encodePacked("INSTITUTION_ADMIN"));

    bytes32 private constant VOTER = keccak256(abi.encodePacked("VOTER"));
    bytes32 private constant PUBLICIST = keccak256(abi.encodePacked("PUBLICIST"));
    bytes32 private constant POLITICAL_ACTOR = keccak256(abi.encodePacked("POLITICAL_ACTOR"));

    constructor() {
        _grantRole(INSTITUTION_ADMIN, msg.sender);
    }

    modifier onlyRole(bytes32 _role) {
        require(
            roles[_role][msg.sender],
            "You are not auhtorized to perform this action"
        );
        _;
    }

    function _grantRole(bytes32 _role, address _account) internal {
        roles[_role][_account] = true;
        emit eGrantRole(_role, _account);
    }

    function _revokeRole(bytes32 _role, address _account) internal {
        roles[_role][_account] = false;
        emit eRevokeRole(_role, _account);
    }

    function _grantMyPublicistRole(address _political_actor_account, address _publicist_account) internal {
        myPublicists[_political_actor_account][_publicist_account] = true;
        emit eGrantMyPulbicistRole(_political_actor_account, _publicist_account);
    }

    function _revokeMyPublicistRole(address _political_actor_account, address _publicist_account) internal {
        myPublicists[_political_actor_account][_publicist_account] = false;
        emit eRevokeMyPulbicistRole(_political_actor_account, _publicist_account);
    }

    // **** grant roles ****
    
    // INSTITUTION_ADMIN
    function grantInstitutionAdminRole(address _account) external onlyRole(INSTITUTION_ADMIN) {
        _grantRole(INSTITUTION_ADMIN, _account);
    }

    function grantVoterRole(address _account) external onlyRole(INSTITUTION_ADMIN) {
        _grantRole(VOTER, _account);
    }

/* // Political actor role granted automatically after election cycle get closed
    function grantPoliticalActorRole(address _account) internal {
        _grantRole(POLITICAL_ACTOR, _account);
    }
*/
    // POLITICAL_ACTOR
    function grantPublicistRole(address _publicist_account) external onlyRole(POLITICAL_ACTOR) {
        _grantMyPublicistRole(msg.sender, _publicist_account);
    }

    // **** revoke roles ****

    function revokeInstitutionAdminRole(address _account) external onlyRole(INSTITUTION_ADMIN) {
        _revokeRole(INSTITUTION_ADMIN, _account);
    }

    function revokeVoterRole(address _account) external onlyRole(INSTITUTION_ADMIN) {
        _revokeRole(VOTER, _account);
    }


    function revokePublicistRole(address _publicist_account) external onlyRole(POLITICAL_ACTOR) {
        _revokeMyPublicistRole(msg.sender, _publicist_account);
    }

}

contract Citizen {
    string public name;

    constructor(string memory _name) {
        name = _name;
    }

    function _getName() external returns(string memory) {
        return name;
    }
}

contract InstitutionAdmin {
    string public name;
    address public citizenAccount;
    address public myInstitutionAddress;

    mapping (address => bool) public supportedAccountsToBeAdmin;

    constructor (string memory _name, address _instituteAccount, address _account) {
        name = _name;
        myInstitutionAddress = _instituteAccount;
        citizenAccount = _account;
        supportedAccountsToBeAdmin[msg.sender] = true;
    }

    function supportAccountToBeAdmin(address _account) internal {
        supportedAccountsToBeAdmin[_account] = true;
        Institution institution = Institution(myInstitutionAddress);

        institution._addAdmin(_account);
    }

    function opposeAccountToBeAdmin(address _account) internal {
        supportedAccountsToBeAdmin[_account] = false;
        Institution institution = Institution(myInstitutionAddress);

        institution._removeAdmin(_account);
    }

    function _isSupportsAccountToBeAdmin(address _account) external returns(bool) {
        return supportedAccountsToBeAdmin[_account];
    }
}

contract Institution is AccessControl {
    Citizen[] public members;
    InstitutionAdmin[] public institutionAdmins;
    address public accessControlAddress;

    constructor(string memory _name) {
        accessControlAddress = address(new AccessControl());
        Citizen citizenAccount = new Citizen(_name);
        createInstitutionAdmin(address(citizenAccount), _name);
    }

    function _addAdmin(address _account) external {
        AccessControl accessControl = AccessControl(accessControlAddress);
        
        if (hasMayorityOfSupportInRoleChange( _account, true)) {
            accessControl.grantInstitutionAdminRole(_account);
            
            createInstitutionAdmin(_account, Citizen(_account)._getName());
        }
    }

    function _removeAdmin(address _account) external {
        AccessControl accessControl = AccessControl(accessControlAddress);

        if (hasMayorityOfSupportInRoleChange( _account, false)) {
            accessControl.revokeInstitutionAdminRole(_account);
            removeInstitutionAdmin(_account);
        }
    }

    function createInstitutionAdmin(address _account, string memory _name) internal {
        InstitutionAdmin _institutionAdmin = new InstitutionAdmin(_name, address(this), _account);
        institutionAdmins.push(_institutionAdmin);
    }

    function removeInstitutionAdmin(address _account) internal {
        uint indexAdminAt = 0;
        bool foundIndex = false;
        for (uint i = 0; i < institutionAdmins.length; i++) {
            if (address(institutionAdmins[i]) == _account) {
                indexAdminAt = i;
                foundIndex = true;
            }
        }

        if (foundIndex) {
            delete institutionAdmins[uint(indexAdminAt)];
        }
    }

    function hasMayorityOfSupportInRoleChange(address _account, bool _decision) internal returns(bool) {
        uint count = 0;
        for (uint i = 0; i < institutionAdmins.length; i++ ) {
           if (institutionAdmins[i]._isSupportsAccountToBeAdmin(_account) == _decision) {
                count++;
           }
        }

        // 2/3 approval is neccessary
        if ( count * 100 / institutionAdmins.length > 66) {
            return true;
        }

        return false;
    }
}

contract Election {

}

contract Voting {

}
