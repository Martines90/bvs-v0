{
  "language": "Solidity",
  "sources": {
    "contracts/BVS_Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// pragma\npragma solidity ^0.8.9;\n\n/**\n * @title Balanced Voting System:Roles - contract\n * @author Márton Sándor Horváth, email: hmartonsandor{@}gmail.com\n * @notice\n * @dev\n */\n\ncontract BVS_Roles {\n    uint public constant MIN_PERCENTAGE_GRANT_ADMIN_APPROVALS_REQUIRED = 50;\n    uint public constant MAX_DAILY_NEW_CITIZENS_CAN_ADD_PERCENTAGE = 10;\n\n    bytes32 public constant ADMINISTRATOR = keccak256(\"ADMINISTRATOR\");\n    bytes32 public constant POLITICAL_ACTOR = keccak256(\"POLITICAL_ACTOR\");\n    bytes32 public constant CITIZEN = keccak256(\"CITIZEN\");\n\n    uint public citizenRoleApplicationFee = 10000;\n\n    address[] public admins;\n    address[] public politicalActors;\n    mapping(address => uint) public politicalActorVotingCredits;\n    address[] public citizens;\n\n    uint public immutable creationDate;\n\n    mapping(address => address[]) public adminApprovalSentToAccount;\n    mapping(address => uint) public adminRoleGrantApprovals;\n\n    mapping(address => mapping(uint => uint))\n        public dailyCitizenRoleModifyCredit;\n\n    mapping(address => bytes32) public citizenshipApplications;\n\n    mapping(bytes32 => mapping(address => bool)) private _hasRole;\n\n    // Events\n\n    event RoleGranted(bytes32 role, address account, address executer);\n\n    event RoleRevoked(bytes32 role, address account, address executer);\n\n    // Errors\n    error CitizenRoleAlreadyGranted();\n    error CitizenRoleAlreadyRevokedOrNotGranted();\n    error NotAppliedForCitizenRole();\n    error RunOutOfDailyCitizenRoleGrantCredit();\n    error AdminRoleGrantApprovalAlreadySent();\n\n    error MinimumApplicationFeeNotCovered();\n\n    error PermissionsUnauthorizedAccount(address account, bytes32 role);\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, msg.sender);\n        _;\n    }\n\n    modifier minCitizenshipApplicationFeeCovered() {\n        if (msg.value < citizenRoleApplicationFee) {\n            revert MinimumApplicationFeeNotCovered();\n        }\n        _;\n    }\n\n    modifier appliedForCitizenRole(address _account, bytes32 _emailPublicKeyHash, bool _revokeCitizenRole) {\n        if (citizenshipApplications[_account] != _emailPublicKeyHash && !_revokeCitizenRole) {\n            revert NotAppliedForCitizenRole();\n        }\n        _;\n    }\n\n    modifier hasRoleToModify(address _account, bool isRevoke) {\n        if (!isRevoke && hasRole(CITIZEN, _account))\n            revert CitizenRoleAlreadyGranted();\n        if (isRevoke && !hasRole(CITIZEN, _account))\n            revert CitizenRoleAlreadyRevokedOrNotGranted();\n        _;\n    }\n\n    modifier hasCitizenRoleGrantCredit() {\n        uint daysPassed = (block.timestamp - creationDate) / 60 / 60 / 24;\n\n        uint maxCitizensCanBeAddPerAdmin = (citizens.length /\n            MAX_DAILY_NEW_CITIZENS_CAN_ADD_PERCENTAGE) / admins.length;\n        maxCitizensCanBeAddPerAdmin = maxCitizensCanBeAddPerAdmin > 0\n            ? maxCitizensCanBeAddPerAdmin\n            : 1;\n\n        if (\n            dailyCitizenRoleModifyCredit[msg.sender][daysPassed] >=\n            maxCitizensCanBeAddPerAdmin\n        ) revert RunOutOfDailyCitizenRoleGrantCredit();\n        _;\n    }\n\n    modifier adminRoleGrantApprovalNotSent(address _account) {\n        bool adminRoleGrantApprovalAlreadySent = false;\n        for (\n            uint i = 0;\n            i < adminApprovalSentToAccount[msg.sender].length;\n            i++\n        ) {\n            if (adminApprovalSentToAccount[msg.sender][i] == _account) {\n                adminRoleGrantApprovalAlreadySent = true;\n            }\n        }\n\n        if (adminRoleGrantApprovalAlreadySent)\n            revert AdminRoleGrantApprovalAlreadySent();\n        _;\n    }\n\n    constructor() {\n        admins.push(msg.sender);\n        adminRoleGrantApprovals[msg.sender] = 1;\n        citizens.push(msg.sender);\n        creationDate = block.timestamp;\n        _setupRole(ADMINISTRATOR, msg.sender);\n        _setupRole(CITIZEN, msg.sender);\n    }\n\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _hasRole[role][account] = true;\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        _checkRole(role, account);\n        delete _hasRole[role][account];\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /// @dev Checks `role` for `account`. Reverts with a message including the required role.\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole[role][account]) {\n            revert PermissionsUnauthorizedAccount(account, role);\n        }\n    }\n\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _hasRole[role][account];\n    }\n\n    function applyForCitizenshipRole(\n        bytes32 _emailPublicKeyCombinedHash\n    ) public payable minCitizenshipApplicationFeeCovered {\n        citizenshipApplications[msg.sender] = _emailPublicKeyCombinedHash;\n    }\n\n    function sendGrantAdministratorRoleApproval(\n        address _account\n    ) public onlyRole(ADMINISTRATOR) adminRoleGrantApprovalNotSent(_account) {\n        adminApprovalSentToAccount[msg.sender].push(_account);\n        adminRoleGrantApprovals[_account]++;\n\n        if (\n            admins.length == 0 ||\n            (adminRoleGrantApprovals[_account] * 1000) / admins.length >\n            MIN_PERCENTAGE_GRANT_ADMIN_APPROVALS_REQUIRED * 10\n        ) {\n            adminRoleGrantApprovals[_account]++;\n            // also new admin has to automatically send his approvals to the already existing admins\n            for (uint i = 0; i < admins.length; i++) {\n                adminApprovalSentToAccount[_account].push(admins[i]);\n                adminRoleGrantApprovals[admins[i]]++;\n            }\n            _setupRole(ADMINISTRATOR, _account);\n            admins.push(_account);\n        }\n    }\n\n    function revokeAdminRoleApproval(\n        address revokedAccount\n    ) public onlyRole(ADMINISTRATOR) {\n        _revokeAdminRoleApproval(msg.sender, revokedAccount);\n    }\n\n    function _revokeAdminRoleApproval(\n        address admin,\n        address revokedAccount\n    ) internal {\n        for (uint i = 0; i < adminApprovalSentToAccount[admin].length; i++) {\n            if (adminApprovalSentToAccount[admin][i] == revokedAccount) {\n                delete adminApprovalSentToAccount[admin][i];\n                adminRoleGrantApprovals[revokedAccount]--;\n                if (\n                    (adminRoleGrantApprovals[revokedAccount] * 1000) /\n                        admins.length <\n                    MIN_PERCENTAGE_GRANT_ADMIN_APPROVALS_REQUIRED * 10\n                ) {\n                    adminRoleGrantApprovals[revokedAccount]--;\n                    _revokeRole(ADMINISTRATOR, revokedAccount);\n                    for (uint u = 0; u < admins.length; u++) {\n                        if (admins[u] == revokedAccount) {\n                            delete admins[u];\n                            admins[u] = admins[admins.length - 1];\n                            admins.pop();\n                            break;\n                        }\n                    }\n                    // make sure all the other admins get revoked their approval receieved from this admin\n                    for (\n                        uint k = 0;\n                        k < adminApprovalSentToAccount[revokedAccount].length;\n                        k++\n                    ) {\n                        _revokeAdminRoleApproval(\n                            revokedAccount,\n                            adminApprovalSentToAccount[revokedAccount][k]\n                        );\n                        delete adminApprovalSentToAccount[revokedAccount][k];\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    function grantCitizenRole(\n        address _account,\n        bytes32 _emailPublicKeyHash,\n        bool _revokeCitizenRole\n    )\n        public\n        onlyRole(ADMINISTRATOR)\n        hasRoleToModify(_account, _revokeCitizenRole)\n        hasCitizenRoleGrantCredit\n        appliedForCitizenRole(_account, _emailPublicKeyHash, _revokeCitizenRole)\n    {\n        uint daysPassed = (block.timestamp - creationDate) / 60 / 60 / 24;\n        dailyCitizenRoleModifyCredit[msg.sender][daysPassed]++;\n        if (!_revokeCitizenRole) {\n            _setupRole(CITIZEN, _account);\n            citizens.push(_account);\n            delete citizenshipApplications[_account];\n        } else {\n            if (hasRole(CITIZEN, _account)) {\n                _revokeRole(CITIZEN, _account);\n            }\n            delete citizenshipApplications[_account];\n            for (uint i; i < citizens.length; i++) {\n                if (citizens[i] == _account) {\n                    delete citizens[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    function updateCitizenshipRoleApplicationFee(\n        uint value\n    ) public onlyRole(ADMINISTRATOR) {\n        citizenRoleApplicationFee = value;\n    }\n\n    function checkIfAccounthasRole(\n        address _account,\n        bytes32 _role\n    ) public view returns (bool) {\n        return hasRole(_role, _account);\n    }\n\n    function getAdminsSize() public view returns (uint) {\n        return admins.length;\n    }\n\n    function getCitizensSize() public view returns (uint) {\n        return citizens.length;\n    }\n\n    function getPoliticalActorsSize() public view returns (uint) {\n        return politicalActors.length;\n    }\n\n    function isEmptyString(string memory _string) public pure returns (bool) {\n        return keccak256(bytes(_string)) == keccak256(bytes(\"\"));\n    }\n}\n"
    },
    "contracts/BVS_Voting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// pragma\npragma solidity ^0.8.9;\n\nimport \"./BVS_Roles.sol\";\n\n/**\n * @title Balanced Voting System: Voting contract\n * @author Márton Sándor Horváth, email: hmartonsandor{@}gmail.com\n * @notice\n * @dev\n */\n\ncontract BVS_Voting is BVS_Roles {\n    // CONSTANTS\n    uint public constant ELECTION_START_END_INTERVAL = 30 days;\n    uint public constant MINIMUM_PERCENTAGE_OF_ELECTION_VOTES = 10;\n\n    uint public constant VOTING_CYCLE_INTERVAL = 30 days;\n    uint public constant VOTING_DURATION = 14 days;\n    uint public constant APPROVE_VOTING_BEFORE_IT_STARTS_LIMIT = 3 days;\n    uint public constant NEW_VOTING_PERIOD_MIN_SCHEDULE_AHEAD_TIME = 10 days;\n\n    uint public constant MIN_TOTAL_CONTENT_READ_CHECK_ANSWER = 10;\n    uint public constant CONTENT_CHECK_ASKED_NUM_OF_QUESTIONS = 5;\n    uint public constant CONTENT_CHECK_ASKED_NUM_OF_QUESTIONS = 5;\n    uint public constant CONTENT_CHECK_ASKED_NUM_OF_QUESTIONS = 5;\n\n    uint public constant MIN_VOTE_SCORE = 5;\n    uint public constant MIN_PERCENTAGE_OF_VOTES = 10;\n\n    // globals\n\n    uint public firstVotingCycleStartDate;\n    uint public electionsCandidateApplicationFee = 10000000;\n\n    uint public electionsStartDate;\n    uint public electionsEndDate;\n\n    // DATA OBJECTS\n\n    struct ProConArticle {\n        bytes32 votingKey;\n        bool isArticleApproved; // admin approves\n        bool isResponseApproved; // admin approves\n        address publisher;\n        string articleIpfsHash;\n        bool isVoteOnA;\n        string responseStatementIpfsHash; // addeed by the creator of the related voting\n        string articleContentCheckQuizIpfsHash; // added by admin\n        string responseContentCheckQuizIpfsHash; // added by admin\n    }\n\n    struct Voting {\n        bool approved;\n        bool cancelled;\n        bytes32 key;\n        uint budget;\n        uint voteCount;\n        address creator;\n        string contentIpfsHash;\n        uint startDate; // 10 days before start date critics can appear\n        uint voteOnAScore;\n        uint voteOnBScore;\n        string votingContentCheckQuizIpfsHash;\n    }\n\n    struct Vote {\n        bool voted;\n        bool isContentCompleted;\n    }\n\n    // mapping(address => uint) public funders;\n\n    // article content check answers\n    mapping(bytes32 => bytes32[]) public articleContentReadCheckAnswers; // article key => answers\n\n    mapping(bytes32 => bytes32[]) public articleContentResponseReadCheckAnswers; // article key => answers\n\n    mapping(bytes32 => bytes32[]) public votingContentReadCheckAnswers; // voting key => answers\n\n    // track the number of votes political actors created during voting cycles\n    mapping(uint => mapping(address => uint)) public votingCycleStartVoteCount;\n\n    // track the number of articles published related to scheduled votings\n    mapping(address => mapping(bytes32 => uint)) // political_actor =>  voting key => published articles count\n        public publishArticleToVotingsCount;\n\n    // register the voting cycle indexes in order to clear votingCycleStartVoteCount data\n    uint[] public votingCycleIndexes;\n\n    // store votings\n    mapping(bytes32 => Voting) public votings;\n\n    // store pro/con articles\n    mapping(bytes32 => mapping(bytes32 => ProConArticle)) public proConArticles; // voting key => article key => article\n\n    // register voting and article keys\n    bytes32[] public votingKeys;\n    bytes32[] public articleKeys;\n\n    mapping(address => mapping(bytes32 => Vote)) public votes;\n\n    mapping(address => bytes32[]) public articlesCompleted;\n    mapping(address => bytes32[]) public articlesResponseCompleted;\n\n    // elections\n\n    address[] public electionCandidates;\n    mapping(address => uint32) public electionCandidateScores;\n\n    mapping(address => address) public electionVotes;\n    address[] public electionVoters;\n\n    // EVENTS\n    event CitizenshipRoleGranted(address to, address from);\n\n    // ERRORS **************************************************************\n\n    error VotingAlreadyStarted();\n    error VotingCanBeApproved3DaysOrLessBeforeItsStart();\n\n    error CantStartNewVointg10daysOrLessBeforeEndOfCycle();\n    error AccountRanOutOfVotingCreditsForThisVotingCycle();\n\n    error ArticleNotExists();\n    error ArticleNotRelatedToYourVoting();\n    error ContentCheckIpfsNotAssigned();\n    error NoArticleContentCheckIpfsAssignedToThisArticle();\n\n    error NoArticleResponseAssigned();\n    error NoArticleResponseContentCheckIpfsAssigned();\n    error NoMorePublishArticleCreditsRelatedToThisVoting();\n\n    error NoEnoughContentReadQuizAnswerAdded();\n\n    error FirstVotingCycleStartDateHasToBeInTheFuture();\n    error NoOngoingVotingPeriod();\n    error NewVotingHasToBeScheduled10DaysAhead();\n    error NewVotingHasToBeScheduledLessThan30daysAhead();\n\n    error VotingNotExists();\n    error VotingNotYetStartedOrAlreadyFinished();\n    error VotingNotBelongsToSender();\n    error VotingDidNotWon();\n    error VotingNotFinished();\n    error VotingNotApproved();\n    error VotingContentCheckQuizNotCompleted();\n    error AlreadyVotedOnThisVoting();\n    error NoEnoughVotesReceived();\n    error VotingContentCheckQuizNotAssigned();\n    error VotingOwnerNotRespondedOnAllArticles();\n\n    // elections\n    error ThereIsAnOngoingElections();\n    error ThereIsNoOngoingElections();\n    error ElectionStartDateHasToBe30DaysAhead();\n\n    error ElectionsNotScheduledOrAlreadyStarted();\n    error AccountAlreadyAppliedForElections();\n    error ElectionsAlreadyFinished();\n    error AccountCantVoteOnItself();\n    error VoteOnAccountNotBelongToAnyCandidate();\n    error AccountAlreadyVoted();\n\n    error ElectionsAlreadyClosedOrNotYetScheduled();\n    error ElectionsCanOnlyCloseAfterItsEndDate();\n\n    modifier criticisedArticleRelatedToYourVoting(\n        bytes32 _votingKey,\n        bytes32 _proConArticleKey\n    ) {\n        if (\n            votings[proConArticles[_votingKey][_proConArticleKey].votingKey]\n                .creator != msg.sender\n        ) revert ArticleNotRelatedToYourVoting();\n        _;\n    }\n\n    modifier hasContentIpfs(bytes32 _votingKey, bytes32 _articleKey) {\n        if (\n            isEmptyString(\n                proConArticles[_votingKey][_articleKey]\n                    .responseContentCheckQuizIpfsHash\n            )\n        ) revert ContentCheckIpfsNotAssigned();\n        _;\n    }\n\n    modifier firstVotingCycleStartDateIsInTheFuture(\n        uint _firstVotingCycleStartDate\n    ) {\n        if (_firstVotingCycleStartDate < block.timestamp) {\n            revert FirstVotingCycleStartDateHasToBeInTheFuture();\n        }\n        _;\n    }\n\n    modifier votingNotYetStarted(bytes32 _votingKey) {\n        if (votings[_votingKey].startDate < block.timestamp) {\n            revert VotingAlreadyStarted();\n        }\n        _;\n    }\n\n    modifier votingWon(bytes32 _votingKey) {\n        if (!isVotingWon(_votingKey, true)) {\n            revert VotingDidNotWon();\n        }\n        _;\n    }\n\n    modifier votingBelongsToSender(bytes32 _votingKey) {\n        if (getVoting(_votingKey).creator != msg.sender) {\n            revert VotingNotBelongsToSender();\n        }\n        _;\n    }\n\n    modifier votingNotFinished(bytes32 _votingKey) {\n        if (votings[_votingKey].startDate + VOTING_DURATION > block.timestamp) {\n            revert VotingNotFinished();\n        }\n        _;\n    }\n\n    modifier votingApproved(bytes32 _votingKey) {\n        if (!votings[_votingKey].approved) {\n            revert VotingNotApproved();\n        }\n        _;\n    }\n\n    modifier enoughVotesArrived(bytes32 _votingKey) {\n        if (\n            (votings[_votingKey].voteCount * 100) / citizens.length <\n            MIN_PERCENTAGE_OF_VOTES\n        ) {\n            revert NoEnoughVotesReceived();\n        }\n        _;\n    }\n\n    modifier votingExists(bytes32 _votingKey) {\n        if (votings[_votingKey].creator == address(0)) {\n            revert VotingNotExists();\n        }\n        _;\n    }\n\n    modifier votingPeriodIsActive() {\n        if (\n            firstVotingCycleStartDate > block.timestamp ||\n            firstVotingCycleStartDate == 0\n        ) {\n            revert NoOngoingVotingPeriod();\n        }\n        _;\n    }\n\n    modifier votingIsOngoing(bytes32 _votingKey) {\n        if (\n            votings[_votingKey].startDate > block.timestamp ||\n            votings[_votingKey].startDate + VOTING_DURATION < block.timestamp\n        ) {\n            revert VotingNotYetStartedOrAlreadyFinished();\n        }\n        _;\n    }\n\n    modifier contentCheckQuizCompleted(bytes32 _votingKey) {\n        if (!votes[msg.sender][_votingKey].isContentCompleted) {\n            revert VotingContentCheckQuizNotCompleted();\n        }\n        _;\n    }\n\n    modifier notVotedYetOnThisVoting(bytes32 _votingKey) {\n        if (votes[msg.sender][_votingKey].voted) {\n            revert AlreadyVotedOnThisVoting();\n        }\n        _;\n    }\n\n    modifier newVotingScheduledAtLeast10daysAhead(uint _startDate) {\n        if (\n            _startDate <\n            block.timestamp + NEW_VOTING_PERIOD_MIN_SCHEDULE_AHEAD_TIME\n        ) {\n            revert NewVotingHasToBeScheduled10DaysAhead();\n        }\n        _;\n    }\n\n    modifier newVotingScheduledMaximum30daysAhead(uint _startDate) {\n        if (_startDate > block.timestamp + VOTING_CYCLE_INTERVAL) {\n            revert NewVotingHasToBeScheduledLessThan30daysAhead();\n        }\n        _;\n    }\n\n    modifier votingContentQuizIpfsAssigned(bytes32 _votingKey) {\n        if (isEmptyString(votings[_votingKey].votingContentCheckQuizIpfsHash)) {\n            revert VotingContentCheckQuizNotAssigned();\n        }\n        _;\n    }\n\n    modifier creatorOfVotingRespondedOnArticles(bytes32 _votingKey) {\n        bool isRespondedAllTheCritics = true;\n        uint articleKeysLength = articleKeys.length;\n\n        for (uint i = 0; i < articleKeysLength; i++) {\n            if (proConArticles[_votingKey][articleKeys[i]].isArticleApproved) {\n                if (\n                    !proConArticles[_votingKey][articleKeys[i]]\n                        .isResponseApproved\n                ) {\n                    isRespondedAllTheCritics = false;\n                    break;\n                }\n            }\n        }\n        if (!isRespondedAllTheCritics) {\n            revert VotingOwnerNotRespondedOnAllArticles();\n        }\n        _;\n    }\n\n    modifier approveAttempt3DaysBeforeVotingStarts(bytes32 _votingKey) {\n        if (\n            votings[_votingKey].startDate -\n                APPROVE_VOTING_BEFORE_IT_STARTS_LIMIT >\n            block.timestamp\n        ) {\n            revert VotingCanBeApproved3DaysOrLessBeforeItsStart();\n        }\n        _;\n    }\n\n    modifier enoughContentReadQuizAnswerAdded(\n        bytes32[] memory _keccak256HashedAnswers\n    ) {\n        if (\n            _keccak256HashedAnswers.length < MIN_TOTAL_CONTENT_READ_CHECK_ANSWER\n        ) {\n            revert NoEnoughContentReadQuizAnswerAdded();\n        }\n        _;\n    }\n\n    modifier hasArticleContentIpfsHashAssigned(\n        bytes32 _votingKey,\n        bytes32 _articleKey\n    ) {\n        if (\n            isEmptyString(\n                proConArticles[_votingKey][_articleKey]\n                    .articleContentCheckQuizIpfsHash\n            )\n        ) {\n            revert NoArticleContentCheckIpfsAssignedToThisArticle();\n        }\n        _;\n    }\n\n    modifier articleShouldExists(bytes32 _votingKey, bytes32 _articleKey) {\n        if (proConArticles[_votingKey][_articleKey].publisher == address(0)) {\n            revert ArticleNotExists();\n        }\n        _;\n    }\n\n    modifier hasArticleReponseAssigned(\n        bytes32 _votingKey,\n        bytes32 _articleKey\n    ) {\n        if (\n            isEmptyString(\n                proConArticles[_votingKey][_articleKey]\n                    .responseStatementIpfsHash\n            )\n        ) {\n            revert NoArticleResponseAssigned();\n        }\n        _;\n    }\n\n    modifier hasArticleResponseContentCheckIpfsHash(\n        bytes32 _votingKey,\n        bytes32 _articleKey\n    ) {\n        if (\n            isEmptyString(\n                proConArticles[_votingKey][_articleKey]\n                    .responseContentCheckQuizIpfsHash\n            )\n        ) {\n            revert NoArticleResponseContentCheckIpfsAssigned();\n        }\n        _;\n    }\n\n    modifier hasCreditsLeftToPublishArticle(bytes32 _votingKey) {\n        if (\n            publishArticleToVotingsCount[msg.sender][_votingKey] >=\n            politicalActorVotingCredits[msg.sender]\n        ) {\n            revert NoMorePublishArticleCreditsRelatedToThisVoting();\n        }\n        _;\n    }\n\n    // elections\n\n    modifier noUnclosedElections() {\n        if (electionsStartDate != 0) {\n            revert ThereIsAnOngoingElections();\n        }\n        _;\n    }\n\n    modifier validApplication() {\n        if (electionsStartDate == 0 || electionsStartDate < block.timestamp) {\n            revert ElectionsNotScheduledOrAlreadyStarted();\n        } else if (electionCandidateScores[msg.sender] > 0) {\n            revert AccountAlreadyAppliedForElections();\n        }\n        _;\n    }\n\n    modifier newElectionsStartDateIs30DaysAhead(uint _electionsStartDate) {\n        if (\n            _electionsStartDate < block.timestamp + ELECTION_START_END_INTERVAL\n        ) {\n            revert ElectionStartDateHasToBe30DaysAhead();\n        }\n        _;\n    }\n\n    modifier validVote(address _voteOnAddress) {\n        if (block.timestamp < electionsStartDate || electionsStartDate == 0) {\n            revert ThereIsNoOngoingElections();\n        } else if (block.timestamp > electionsEndDate) {\n            revert ElectionsAlreadyFinished();\n        } else if (msg.sender == _voteOnAddress) {\n            revert AccountCantVoteOnItself();\n        } else if (electionCandidateScores[_voteOnAddress] == 0) {\n            revert VoteOnAccountNotBelongToAnyCandidate();\n        } else if (electionVotes[msg.sender] != address(0)) {\n            revert AccountAlreadyVoted();\n        }\n        _;\n    }\n\n    modifier canCloseElections() {\n        if (electionsStartDate == 0) {\n            revert ElectionsAlreadyClosedOrNotYetScheduled();\n        } else if (electionsEndDate + 7 days > block.timestamp) {\n            revert ElectionsCanOnlyCloseAfterItsEndDate();\n        }\n        _;\n    }\n\n    modifier minCandidateApplicationFeeCovered() {\n        if (msg.value < electionsCandidateApplicationFee) {\n            revert MinimumApplicationFeeNotCovered();\n        }\n        _;\n    }\n\n    // CONTRACT LOGIC *****************************************************************\n\n    constructor() BVS_Roles() {}\n\n    receive() external payable {}\n\n    function getBlockTime() public view returns (uint256) {\n        return block.timestamp;\n    }\n\n    function scheduleNextElections(\n        uint256 _electionsStartDate,\n        uint256 _electionsEndDate\n    )\n        public\n        onlyRole(ADMINISTRATOR)\n        noUnclosedElections\n        newElectionsStartDateIs30DaysAhead(_electionsStartDate)\n    {\n        electionsStartDate = _electionsStartDate;\n        electionsEndDate = _electionsEndDate;\n\n        for (uint i = 0; i < politicalActors.length; i++) {\n            _revokeRole(POLITICAL_ACTOR, politicalActors[i]);\n            delete politicalActorVotingCredits[politicalActors[i]];\n            delete politicalActors[i];\n        }\n        politicalActors = new address[](0);\n    }\n\n    function applyForElections()\n        public\n        payable\n        onlyRole(CITIZEN)\n        minCandidateApplicationFeeCovered\n        validApplication\n    {\n        electionCandidates.push(msg.sender);\n        electionCandidateScores[msg.sender] = 1;\n    }\n\n    function voteOnElections(\n        address voteOnAddress\n    ) public onlyRole(CITIZEN) validVote(voteOnAddress) {\n        electionVotes[msg.sender] = voteOnAddress;\n        electionVoters.push(msg.sender);\n        electionCandidateScores[voteOnAddress]++;\n    }\n\n    function closeElections() public onlyRole(ADMINISTRATOR) canCloseElections {\n        // assign roles to the winners\n        uint256 totalVotes = electionVoters.length;\n        for (uint i = 0; i < electionCandidates.length; i++) {\n            uint256 votesOwnedPercentage = ((electionCandidateScores[\n                electionCandidates[i]\n            ] - 1) * 1000) / totalVotes;\n\n            if (votesOwnedPercentage > MINIMUM_PERCENTAGE_OF_ELECTION_VOTES) {\n                uint256 votingCycleTotalCredit = (votesOwnedPercentage -\n                    MINIMUM_PERCENTAGE_OF_ELECTION_VOTES *\n                    10) /\n                    100 +\n                    1;\n\n                _setupRole(POLITICAL_ACTOR, electionCandidates[i]);\n                politicalActors.push(electionCandidates[i]);\n                politicalActorVotingCredits[\n                    electionCandidates[i]\n                ] = votingCycleTotalCredit;\n            }\n\n            delete electionCandidateScores[electionCandidates[i]];\n        }\n\n        electionCandidates = new address[](0);\n        electionVoters = new address[](0);\n\n        electionsStartDate = 0;\n    }\n\n    function unlockVotingBudget(\n        bytes32 _votingKey\n    )\n        public\n        onlyRole(POLITICAL_ACTOR)\n        votingBelongsToSender(_votingKey)\n        votingWon(_votingKey)\n    {\n        (bool callSuccess, ) = payable(msg.sender).call{\n            value: getVoting(_votingKey).budget\n        }(\"\");\n        if (!callSuccess) {\n            revert();\n        }\n\n        votings[_votingKey].budget = 0; // make sure no more money can be requested\n    }\n\n    function setFirstVotingCycleStartDate(\n        uint _firstVotingCycleStartDate\n    )\n        public\n        onlyRole(ADMINISTRATOR)\n        firstVotingCycleStartDateIsInTheFuture(_firstVotingCycleStartDate)\n    {\n        // reset votingCycleStartVoteCount;\n        for (uint i = 0; i < votingCycleIndexes.length; i++) {\n            for (uint u = 0; u < politicalActors.length; u++) {\n                delete votingCycleStartVoteCount[votingCycleIndexes[i]][\n                    politicalActors[u]\n                ];\n            }\n        }\n\n        votingCycleIndexes = new uint[](0);\n\n        firstVotingCycleStartDate = _firstVotingCycleStartDate;\n    }\n\n    function scheduleNewVoting(\n        string calldata _contentIpfsHash,\n        uint _startDate,\n        uint _budget\n    )\n        public\n        onlyRole(POLITICAL_ACTOR)\n        votingPeriodIsActive\n        newVotingScheduledAtLeast10daysAhead(_startDate)\n        newVotingScheduledMaximum30daysAhead(_startDate)\n    {\n        uint timePassed = block.timestamp - firstVotingCycleStartDate;\n        uint votingCycleCount = uint(timePassed / VOTING_CYCLE_INTERVAL);\n\n        if (\n            timePassed - votingCycleCount * VOTING_CYCLE_INTERVAL >\n            VOTING_CYCLE_INTERVAL - NEW_VOTING_PERIOD_MIN_SCHEDULE_AHEAD_TIME\n        ) {\n            revert CantStartNewVointg10daysOrLessBeforeEndOfCycle();\n        }\n\n        if (\n            politicalActorVotingCredits[msg.sender] <=\n            votingCycleStartVoteCount[votingCycleCount][msg.sender]\n        ) {\n            revert AccountRanOutOfVotingCreditsForThisVotingCycle();\n        }\n\n        votingCycleStartVoteCount[votingCycleCount][msg.sender]++;\n\n        bytes32 _votingKey = keccak256(\n            abi.encodePacked(block.timestamp, msg.sender, _contentIpfsHash)\n        );\n\n        votings[_votingKey].budget = _budget;\n        votings[_votingKey].key = _votingKey;\n        votings[_votingKey].creator = msg.sender;\n        votings[_votingKey].contentIpfsHash = _contentIpfsHash;\n        votings[_votingKey].startDate = _startDate;\n        votings[_votingKey].voteOnAScore = 0;\n        votings[_votingKey].voteOnBScore = 0;\n\n        bool votingCycleIndexAlreadyAdded = false;\n        for (uint i = 0; i < votingCycleIndexes.length; i++) {\n            if (votingCycleCount == votingCycleIndexes[i]) {\n                votingCycleIndexAlreadyAdded = true;\n                break;\n            }\n        }\n\n        if (!votingCycleIndexAlreadyAdded) {\n            votingCycleIndexes.push(votingCycleCount);\n        }\n\n        votingKeys.push(_votingKey);\n    }\n\n    function assignQuizIpfsHashToVoting(\n        bytes32 _votingKey,\n        string memory _quizIpfsHash\n    ) public onlyRole(ADMINISTRATOR) votingExists(_votingKey) {\n        votings[_votingKey].votingContentCheckQuizIpfsHash = _quizIpfsHash;\n    }\n\n    function addKeccak256HashedAnswersToVotingContent(\n        bytes32 _votingKey,\n        bytes32[] memory _keccak256HashedAnswers\n    )\n        public\n        onlyRole(ADMINISTRATOR)\n        votingContentQuizIpfsAssigned(_votingKey)\n        enoughContentReadQuizAnswerAdded(_keccak256HashedAnswers)\n    {\n        votingContentReadCheckAnswers[_votingKey] = _keccak256HashedAnswers;\n    }\n\n    function approveVoting(\n        bytes32 _votingKey\n    )\n        public\n        onlyRole(ADMINISTRATOR)\n        votingNotYetStarted(_votingKey)\n        approveAttempt3DaysBeforeVotingStarts(_votingKey)\n        enoughContentReadQuizAnswerAdded(\n            votingContentReadCheckAnswers[_votingKey]\n        )\n        creatorOfVotingRespondedOnArticles(_votingKey)\n    {\n        votings[_votingKey].approved = true;\n    }\n\n    function publishProConArticle(\n        bytes32 _votingKey,\n        string memory _ipfsHash,\n        bool _isVoteOnA\n    )\n        public\n        onlyRole(POLITICAL_ACTOR)\n        hasCreditsLeftToPublishArticle(_votingKey)\n    {\n        bytes32 articleKey = keccak256(\n            abi.encodePacked(block.timestamp, msg.sender, _ipfsHash)\n        );\n\n        proConArticles[_votingKey][articleKey] = ProConArticle(\n            _votingKey,\n            false,\n            false,\n            msg.sender,\n            _ipfsHash,\n            _isVoteOnA,\n            \"\",\n            \"\",\n            \"\"\n        );\n        articleKeys.push(articleKey);\n        publishArticleToVotingsCount[msg.sender][_votingKey]++;\n    }\n\n    function assignQuizIpfsHashToArticleOrResponse(\n        bytes32 _votingKey,\n        bytes32 _articleKey,\n        string memory _quizIpfsHash,\n        bool assignToArticleContent\n    )\n        public\n        onlyRole(ADMINISTRATOR)\n        articleShouldExists(_votingKey, _articleKey)\n    {\n        if (assignToArticleContent) {\n            proConArticles[_votingKey][_articleKey]\n                .articleContentCheckQuizIpfsHash = _quizIpfsHash;\n        } else {\n            proConArticles[_votingKey][_articleKey]\n                .responseContentCheckQuizIpfsHash = _quizIpfsHash;\n        }\n    }\n\n    function addKeccak256HashedAnswersToArticle(\n        bytes32 _votingKey,\n        bytes32 _articleKey,\n        bytes32[] memory _keccak256HashedAnswers\n    )\n        public\n        onlyRole(ADMINISTRATOR)\n        hasArticleContentIpfsHashAssigned(_votingKey, _articleKey)\n        enoughContentReadQuizAnswerAdded(_keccak256HashedAnswers)\n    {\n        proConArticles[_votingKey][_articleKey].isArticleApproved = true;\n        articleContentReadCheckAnswers[_articleKey] = _keccak256HashedAnswers;\n    }\n\n    function publishProConArticleResponse(\n        bytes32 _votingKey,\n        bytes32 _proConArticleKey,\n        string memory _ipfsHash\n    )\n        public\n        onlyRole(POLITICAL_ACTOR)\n        votingNotYetStarted(_votingKey)\n        criticisedArticleRelatedToYourVoting(_votingKey, _proConArticleKey)\n    {\n        proConArticles[_votingKey][_proConArticleKey]\n            .responseStatementIpfsHash = _ipfsHash;\n    }\n\n    function addKeccak256HashedAnswersToArticleResponse(\n        bytes32 _votingKey,\n        bytes32 _articleKey,\n        bytes32[] memory _keccak256HashedAnswers\n    )\n        public\n        onlyRole(ADMINISTRATOR)\n        articleShouldExists(_votingKey, _articleKey)\n        hasArticleReponseAssigned(_votingKey, _articleKey)\n        hasArticleResponseContentCheckIpfsHash(_votingKey, _articleKey)\n        votingNotYetStarted(_votingKey)\n        enoughContentReadQuizAnswerAdded(_keccak256HashedAnswers)\n    {\n        articleContentResponseReadCheckAnswers[\n            _articleKey\n        ] = _keccak256HashedAnswers;\n        proConArticles[_votingKey][_articleKey].isResponseApproved = true;\n    }\n\n    function completeContentReadQuiz(\n        uint contentType,\n        bytes32 _votingKey,\n        bytes32 _articleKey,\n        string[] memory _answers\n    ) public onlyRole(CITIZEN) {\n        uint[] memory answerIndexes;\n        bool isCorrect;\n\n        // voting\n        if (contentType == 1) {\n            answerIndexes = getAccountVotingQuizAnswerIndexes(\n                _votingKey,\n                msg.sender\n            );\n\n            isCorrect = isContentReadQuizCorrect(\n                answerIndexes,\n                votingContentReadCheckAnswers[_votingKey],\n                _answers\n            );\n            votes[msg.sender][_votingKey].isContentCompleted = true;\n        }\n        // article\n        else if (contentType == 2) {\n            answerIndexes = getAccountArticleQuizAnswerIndexes(\n                _votingKey,\n                _articleKey,\n                msg.sender\n            );\n\n            isCorrect = isContentReadQuizCorrect(\n                answerIndexes,\n                articleContentReadCheckAnswers[_articleKey],\n                _answers\n            );\n            articlesCompleted[msg.sender].push(_articleKey);\n            // article respond\n        } else if (contentType == 3) {\n            answerIndexes = getAccountArticleResponseQuizAnswerIndexes(\n                _votingKey,\n                _articleKey,\n                msg.sender\n            );\n\n            isCorrect = isContentReadQuizCorrect(\n                answerIndexes,\n                articleContentResponseReadCheckAnswers[_articleKey],\n                _answers\n            );\n\n            articlesResponseCompleted[msg.sender].push(_articleKey);\n        }\n\n        require(isCorrect, \"Some of your provided answers are wrong\");\n    }\n\n    function calculateVoteScore(\n        bytes32 _votingKey,\n        address _account\n    ) public view returns (uint) {\n        uint voteScore = MIN_VOTE_SCORE;\n\n        uint completedArticlesLength = articlesCompleted[_account].length;\n\n        uint numOfVoteOnACompletedArticleValue = 0;\n        uint numOfVoteOnBCompletedArticleValue = 0;\n\n        uint numOfVoteOnACompletedResponseValue = 0;\n        uint numOfVoteOnBCompletedResponseValue = 0;\n\n        for (uint i = 0; i < completedArticlesLength; i++) {\n            ProConArticle memory completedProConArticle = proConArticles[\n                _votingKey\n            ][articlesCompleted[_account][i]];\n            if (completedProConArticle.votingKey == _votingKey) {\n                if (completedProConArticle.isVoteOnA) {\n                    numOfVoteOnACompletedArticleValue += 1;\n                } else {\n                    numOfVoteOnBCompletedArticleValue += 1;\n                }\n            }\n        }\n\n        uint completedArticlesResponseLength = articlesResponseCompleted[\n            _account\n        ].length;\n        for (uint u = 0; u < completedArticlesResponseLength; u++) {\n            ProConArticle\n                memory completedProConArticleWithResponse = proConArticles[\n                    _votingKey\n                ][articlesResponseCompleted[_account][u]];\n            if (completedProConArticleWithResponse.votingKey == _votingKey) {\n                if (completedProConArticleWithResponse.isVoteOnA) {\n                    numOfVoteOnACompletedResponseValue += 1;\n                } else {\n                    numOfVoteOnBCompletedResponseValue += 1;\n                }\n            }\n        }\n\n        uint noPairArticleCompleteCount = 0;\n\n        if (\n            numOfVoteOnACompletedArticleValue >\n            numOfVoteOnBCompletedArticleValue\n        ) {\n            noPairArticleCompleteCount = (numOfVoteOnACompletedArticleValue -\n                numOfVoteOnBCompletedArticleValue);\n        } else {\n            noPairArticleCompleteCount = (numOfVoteOnBCompletedArticleValue -\n                numOfVoteOnACompletedArticleValue);\n        }\n\n        voteScore +=\n            ((numOfVoteOnACompletedArticleValue +\n                numOfVoteOnBCompletedArticleValue -\n                noPairArticleCompleteCount) / 2) *\n            25 +\n            (noPairArticleCompleteCount * 5);\n\n        // add the balanced way calculated scores after completed responses\n        uint noPairResponseCompleteCount = 0;\n\n        if (\n            numOfVoteOnACompletedResponseValue >\n            numOfVoteOnBCompletedResponseValue\n        ) {\n            noPairResponseCompleteCount = (numOfVoteOnACompletedResponseValue -\n                numOfVoteOnBCompletedResponseValue);\n        } else {\n            noPairResponseCompleteCount = (numOfVoteOnBCompletedResponseValue -\n                numOfVoteOnACompletedResponseValue);\n        }\n\n        voteScore +=\n            ((numOfVoteOnACompletedResponseValue +\n                numOfVoteOnBCompletedResponseValue -\n                noPairResponseCompleteCount) / 2) *\n            10 +\n            (noPairResponseCompleteCount * 2);\n\n        return voteScore;\n    }\n\n    function voteOnVoting(\n        bytes32 _votingKey,\n        bool _voteOnA\n    )\n        public\n        onlyRole(CITIZEN)\n        votingIsOngoing(_votingKey)\n        votingApproved(_votingKey)\n        contentCheckQuizCompleted(_votingKey)\n        notVotedYetOnThisVoting(_votingKey)\n    {\n        // calculate vote score\n        uint voteScore = calculateVoteScore(_votingKey, msg.sender);\n\n        // add new vote\n        if (_voteOnA) {\n            votings[_votingKey].voteOnAScore += voteScore;\n        } else {\n            votings[_votingKey].voteOnBScore += voteScore;\n        }\n\n        votings[_votingKey].voteCount++;\n        votes[msg.sender][_votingKey].voted = true;\n    }\n\n    function getAccountVotingQuizAnswerIndexes(\n        bytes32 _votingKey,\n        address _account\n    ) public view returns (uint[] memory) {\n        return\n            getAccountQuizAnswerIndexes(\n                votings[_votingKey].votingContentCheckQuizIpfsHash,\n                votings[_votingKey].contentIpfsHash,\n                votings[_votingKey].startDate,\n                votingContentReadCheckAnswers[_votingKey].length,\n                CONTENT_CHECK_ASKED_NUM_OF_QUESTIONS,\n                _account\n            );\n    }\n\n    function getAccountArticleQuizAnswerIndexes(\n        bytes32 _votingKey,\n        bytes32 _articleKey,\n        address _account\n    ) public view returns (uint[] memory) {\n        return\n            getAccountQuizAnswerIndexes(\n                proConArticles[_votingKey][_articleKey]\n                    .articleContentCheckQuizIpfsHash,\n                proConArticles[_votingKey][_articleKey].articleIpfsHash,\n                votings[_votingKey].startDate,\n                articleContentReadCheckAnswers[_articleKey].length,\n                CONTENT_CHECK_ASKED_NUM_OF_QUESTIONS,\n                _account\n            );\n    }\n\n    function getAccountArticleResponseQuizAnswerIndexes(\n        bytes32 _votingKey,\n        bytes32 _articleKey,\n        address _account\n    ) public view returns (uint[] memory) {\n        return\n            getAccountQuizAnswerIndexes(\n                proConArticles[_votingKey][_articleKey]\n                    .responseContentCheckQuizIpfsHash,\n                proConArticles[_votingKey][_articleKey]\n                    .responseStatementIpfsHash,\n                votings[_votingKey].startDate,\n                articleContentResponseReadCheckAnswers[_articleKey].length,\n                CONTENT_CHECK_ASKED_NUM_OF_QUESTIONS,\n                _account\n            );\n    }\n\n    function isContentReadQuizCorrect(\n        uint[] memory _answerIndexes,\n        bytes32[] memory _readCheckAnswers,\n        string[] memory _answers\n    ) public view onlyRole(CITIZEN) returns (bool) {\n        bool areAnswersCorrect = true;\n\n        for (uint i = 0; i < _answerIndexes.length; i++) {\n            if (\n                _readCheckAnswers[_answerIndexes[i] - 1] !=\n                keccak256(bytes(_answers[i]))\n            ) {\n                areAnswersCorrect = false;\n            }\n        }\n\n        return areAnswersCorrect;\n    }\n\n    function getAccountQuizAnswerIndexes(\n        string memory ipfsHash1,\n        string memory ipfsHash2,\n        uint _date,\n        uint _numOfTotalQuestions,\n        uint _numOfQuiestionsToAsk,\n        address _account\n    ) internal pure returns (uint[] memory) {\n        bytes32 hashCode = keccak256(\n            abi.encodePacked(ipfsHash1, ipfsHash2, _account)\n        );\n\n        uint numOfVotingQuizQuestions = uint(_numOfTotalQuestions);\n\n        uint[] memory questionsToAsk = new uint[](_numOfQuiestionsToAsk);\n\n        uint countAddedQuestions = 0;\n        for (\n            uint i = uint(_date % numOfVotingQuizQuestions);\n            countAddedQuestions < _numOfQuiestionsToAsk;\n            i++\n        ) {\n            uint questionNth = (uint8(hashCode[i]) % numOfVotingQuizQuestions) +\n                1;\n\n            uint u = 0;\n            do {\n                if (questionsToAsk[u] == questionNth) {\n                    questionNth++;\n                    u = 0;\n                    if (questionNth > numOfVotingQuizQuestions) {\n                        questionNth = 1;\n                    }\n                } else {\n                    u++;\n                }\n            } while (u < countAddedQuestions);\n\n            questionsToAsk[countAddedQuestions] = questionNth;\n            countAddedQuestions++;\n        }\n\n        return questionsToAsk;\n    }\n\n    function isVotingWon(\n        bytes32 _votingKey,\n        bool _isAWinExpected\n    )\n        public\n        view\n        votingNotFinished(_votingKey)\n        votingApproved(_votingKey)\n        enoughVotesArrived(_votingKey)\n        returns (bool)\n    {\n        if (_isAWinExpected) {\n            return\n                votings[_votingKey].voteOnAScore >=\n                votings[_votingKey].voteOnBScore;\n        } else {\n            return\n                votings[_votingKey].voteOnBScore >\n                votings[_votingKey].voteOnAScore;\n        }\n    }\n\n    function getVoting(bytes32 _votingKey) public view returns (Voting memory) {\n        return votings[_votingKey];\n    }\n\n    function getVotingKeysLength() public view returns (uint) {\n        return votingKeys.length;\n    }\n\n    function getArticleKeysLength() public view returns (uint) {\n        return articleKeys.length;\n    }\n\n    function getVotinCycleIndexesSize() public view returns (uint) {\n        return votingCycleIndexes.length;\n    }\n\n    function getElectionCandidatesSize() public view returns (uint256) {\n        return electionCandidates.length;\n    }\n\n    function getElectionVotersSize() public view returns (uint256) {\n        return electionVoters.length;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}